# TO-DO

## 技术选型

- 前端框架：Vue
- 游戏引擎：Phaser.js
- 通信协议：WebSocket & HTTP
- 后端框架：SpringBoot
- 数据库：Mysql
- 缓存：Redis
- 安全框架：Sa-Token

## 架构设计

- Nginx做反向代理和负载均衡
- 多个Java服务器：一个Java服务器负责一个地图，不过rest请求还是可以用nginx做负载均衡
- Redis做缓存
- MySQL做持久化

## 部署

使用docker-compose吧，暂时不上k8s

如何用nginx反向代理websocket？参见 https://blog.csdn.net/qq_25919479/article/details/126035517

## 通信格式

对于实时信息，使用websocket进行通信：

客户端发生事件（例如玩家被攻击）时，向服务器发送如下信息：

```json
{
    "type": "attack",
    "data": {
        "attacker": "attackerID",
        "victim": "victimID"
    }
}
```

同理，服务器向客户端返回的消息也同样是这种格式。

对于Rest API，通信格式如下：

```
{
	"code": 1,
	"msg": "用户不存在",
	"data": {}
}
```

## 缓存

- 使用redis作为缓存（直接用cachable的注解吧，比较方便）
- 对于每个地图独有的数据，例如物品的坐标，不需要redis，直接用java的并发容器放在Java内存里比较快，但需要定期写回MySQL

## 前端

### matter碰撞更加优雅

您可以尝试使用一个对象来存储不同类型物体之间的碰撞处理函数，这样可以避免在 `collisionstart` 事件处理器中使用大量的 `if` 语句。以下是一个示例：

1. 首先，定义一个对象来存储不同类型物体之间的碰撞处理函数：

```javascript
const collisionHandlers = {
  player_enemy: function(player, enemy) {
    // 玩家与敌人碰撞的逻辑
  },
  player_collectible: function(player, collectible) {
    // 玩家与可收集物体碰撞的逻辑
  },
  // 更多处理函数...
};
```

2. 然后，在 `collisionstart` 事件处理器中，根据碰撞物体的类别来调用相应的处理函数：

```javascript
this.matter.world.on('collisionstart', (event, bodyA, bodyB) => {
  const categories = [bodyA.collisionFilter.category, bodyB.collisionFilter.category].sort();
  const handlerKey = categories.join('_');

  if (collisionHandlers.hasOwnProperty(handlerKey)) {
    collisionHandlers[handlerKey](bodyA.gameObject, bodyB.gameObject);
  }
});
```

这样，您可以将碰撞处理逻辑与事件处理器分离，使代码更加清晰和易于维护。当然，这种方法仍然需要您为不同类型物体之间的碰撞定义处理函数，但它可以避免在 `collisionstart` 事件处理器中使用大量的 `if` 语句。

### 图片素材

bing

### 音频素材

jsfxr

## 物品模块

- player_item表
- item_status表，物品对使用者状态的影响，以及持续时间


## 游戏模块

### 算法

使用观察者模式：

观察者模式使用map实现，避免isinstanceof

```java
class ObserverNotifier {
    Map<EventEnum, List<Observer>> map;
    notifyAll(EventEnum);
}

class Observer {
    update();
}

class XXObserver {
    Map<EventEnum, Function> mp;
}
```

同时，还需要使用状态机维护观察者的状态

## 寻路模块

放到utils包里面吧

地图信息的导出，用Python通过physicsEditor的输出将建筑转化为bitmap

我们进行一次新寻路的条件判断, 主要抓住的是时间和位置. 如果时间间隔不够大(比如未到0.5sec), 就不寻路; 如果玩家没有移动, 那么怪物单位也没有必要再次进行寻路计算, 用之前的路线即可.


只取下面一部分的凹多面体（用于寻路算法，需要配合下面要将的算法）bitmap.json

> 引射线法是一种可行的方法来判断点是否在二维凹多边形内部。这种方法的基本思想是从目标点发出一条射线，然后统计射线与多边形边界的交点数目。如果交点数目是奇数，那么目标点在多边形内部；如果交点数目是偶数，那么目标点在多边形外部。

> 这种方法的正确性基于射线穿过多边形边界的次数。当射线穿过多边形边界时，它必然从多边形的内部穿到外部，或者从外部穿到内部。因此，如果交点数目是奇数，那么射线从多边形内部穿出了奇数次，说明目标点在多边形内部。相反，如果交点数目是偶数，那么射线从多边形内部穿出了偶数次，说明目标点在多边形外部。

> 下面是一个使用 Python 实现的示例：

```python
def is_point_inside_polygon(point, polygon):
    x, y = point
    n = len(polygon)
    inside = False

    p1x, p1y = polygon[0]
    for i in range(1, n + 1):
        p2x, p2y = polygon[i % n]
        if y > min(p1y, p2y):
            if y <= max(p1y, p2y):
                if x <= max(p1x, p2x):
                    if p1y != p2y:
                        x_intersection = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x
                    if p1x == p2x or x <= x_intersection:
                        inside = not inside
        p1x, p1y = p2x, p2y

    return inside

# 测试
point = (3, 4)
polygon = [(0, 0), (5, 0), (
```

## 状态模块

status表：状态id，状态名，描述

player_status表

## 宠物模块

pet表存储description信息等

player_pet表只存储放在背包里的宠物，放在地图上的宠物由地图模块管理

- 怪和宠物有除了金钱外的其他属性（经验值、等级、饱腹值、血量、攻击、防御、速度）
- 其他参见玩家模块

## 猫猫模块

除了pet表，每种宠物还要再做一张表cat，cat里面有猫的各个属性，以及主人什么的

- 每种宠物有一个对应的bean
- 每种宠物有一个对应的observer
- observer应该实现一些接口，例如Attackable，里面有attack方法，这样的话，当攻击事件发生，被攻击者监听该事件，根据攻击者的attack方法的结果做一些操作，另外，如果有一些公共的东西，那就用公用工具类而不要用继承

## 商店模块

模块设计要变一下，不能都作为建筑模块，建筑模块只管建造什么的，每个建筑都要有自己的模块

## 玩家模块

- 经验值每到100就导致等级升一级
- 饱腹值最高为100，高于80时会定期回复血量
- 玩家可装备装备，有护甲、鞋子、左手、右手四种，装备不仅可以更新玩家的属性值，还可以有一些神奇的效果，例如剧毒手套可以使攻击对方时对方持续性的伤血
- 角色可以有特殊状态，例如中毒状态（持续性的伤血）、虚无状态（当晚受到攻击有30%概率miss）
- 玩家可以食用食物，以提高各种属性值，也能使玩家进入某种状态
- 角色的等级提升会提高各属性值，并解锁之前不能购买的商品或者是工厂里不能制作的东西
- 玩家可以左键点击其他玩家以查看其他玩家的属性

## 账号模块

- 玩家第1次作弊（例如瞬移）会被警告，第2次封号7天，第3次封号30天，第4次永久封号

## 地图模块

- 玩家可以选择地图
- 同一地图上应该能够同时容纳多个玩家
- 地图背景是石地以及一些交叉的小路
- 地图上存储了所有建筑以及各种物体的位置信息

## 时间模块

- 时间包含黎明、白天、黄昏、晚上
- 界面上要显示出当前时间段对应的图标，背景颜色也要随之变化，以告知用户当前时间
- 只有晚上会生成一些怪
- 黎明时怪开始迅速受伤死亡

## 建筑模块

- 建筑包含商店、农田、树、草地、池塘、工厂、铁矿等
- 玩家可以采集材料、建造建筑
- 建筑可以升级，提高产出和效率
- 商店可以进行买卖交易，但是卖出价格相比买入价格要低，玩家自己创建的商店，当发生交易时，自己会获得部分收益（金钱和经验值）
- 池塘可以捕鱼（需要手持鱼竿），需要花费一定时间，玩家创建的池塘，如果被别人捕鱼，自己也会获得部分收益（金钱和经验值）
- 铁矿可以挖铁（需要手持锄头），需要花费一定时间，玩家创建的铁矿，如果被别人挖铁，自己也会获得部分收益（金钱和经验值）
- 树可以用来砍（手持锯子时）或摘苹果（手不持锯子时），需要花费一定时间，玩家种植的树，如果被别人使用，自己也会获得部分收益（金钱和经验值）
- 工厂可以使用各种物品合成各种商店买不到的东西，例如各种建筑或珍贵物品，玩家自己创建的工厂，当发生交易时，自己会获得部分收益（金钱和经验值）
- 这些建筑里面可获得的东西，量都是有限的，当然也会定期（例如黎明的瞬间）自动补充

### 算法

前端：首先怎么在客户端检测位置是否合法？弄一个polygon然后检测碰撞？注意不要与建筑之外的东西产生碰撞，也就是，还需要弄mask

## 聊天模块

- 玩家之间可以聊天
- 玩家也可以广播消息
- 聊天内容会被保留7天

## 战斗模块

- 玩家之间不能战斗
- 只有玩家与怪之间、怪与怪之间才会战斗
- 怪物分为近身攻击和远程攻击两种，它们会寻找一定范围内的玩家，并进行攻击。近身攻击的怪是蜘蛛（蜘蛛在遭到碰撞时会旋转）
- 玩家能够进行两种攻击，右键对手时会朝对方发射子弹，子弹只能攻击敌人，而会穿过其他玩家
- 玩家右键点击自己可以进行范围攻击
- 玩家对怪造成伤害，会增加自己的经验值
- 玩家杀死怪时，会增加自己的经验值和金钱

## NPC模块

- 玩家可以饲养宠物
- 狗会跟随你，在自己或主人遭到攻击时会反击
- 猫会不定期为你捕鱼，并且跑得很快，较难被攻击到
- 玩家养的牛可以宰杀，收获牛革和牛肉，牛革可以做皮质胸甲以及其他物品
- 牛会在草地附近移动，在草地附近才会繁殖，牛有寿命，牛也不能被怪物或其他玩家攻击
- 游戏中可以加入基于ChatGPT的AI虚拟人物，这些AI可以自由活动，也可以和玩家进行交互

## 移动端适配

- 在PC端，点击左键显示一个东西的信息，点击右键攻击他，在地图上右键一个位置移动到那里
- 在移动端，点击一个东西攻击他，在地图上点击一个位置移动到那里，长按显示一个东西的信息

