# TODO

- 已知的bug：补间动画的精灵碰撞到带有速度的精灵，补间动画的精灵会再也无法正常运动，尝试在补间动画之前将速度设为0，这样的效果稍微好点，在碰到移动的物体后会像撞到一堵墙一样停止，但之后尝试运动还是可以正常运动，但目前能想到的最好的方法是在update中一直将补间动画的精灵的速度设为0
- 已知的bug：很偶尔的情况下，时间会变为白天0/300秒，并且刷新前端也无效，这似乎说明后端的endTime是在当前时间之前。但为什么会这样呢？下次观察一下出现这个问题时TimeScheduler有没有抛出异常
- 已知的bug：切换账号后，操纵的还是旧的玩家（旧的ws没有断开），需要刷新网页才能避免这个问题
- 自动生成各种枚举类（可借助rest api）
- 优化自动生成各个说明文档（可借助rest api），这些生成脚本不应该删除已有的介绍内容，例如对狗狗行为规则的介绍，同时应该展示物品的详细信息（例如给精灵带来的效果）
- 添加修道院：一个修炼场所，精灵呆在里面一定时间可以获得特殊效果，例如“一定概率秒杀对方”或者“经验球”
- 设计以下武器：
  - 埃阿斯之盾：减少7点伤害
  - 雷霆之杖（LightningBolts）：无视对方防具，并对对方造成30s烧伤效果
  - 青龙偃月刀：一定概率秒杀对方
  - 湖中剑：造成特定数值的固定伤害
  - 荷鲁斯之眼：生命和饱腹值恢复到100，并带有30s生命效果
- 对于效果，设计一个value值和等级值
- 待定：简化设计，废弃整个物理引擎（因为bug太多了，不仅要解决自己代码的bug，还要解决物理引擎的上游bug），进而，可以简化前后端交互（废弃COORDINATE request，服务器不再需要通过前端获得位置信息）和后端设计（废弃SpriteCache，因为SpriteCache的主要目的就是缓存精灵位置，便于COORDINATE）
- 使用二进制指数回退进行websocket重连
- 各属性值的上限不应该是简单的100
- claude2的建议：
  - 在SpriteService类中处理战斗逻辑,可以抽象成单独的CombatService类,职责更清晰。
  - 在游戏时间系统中,可以使用更灵活的方式表示时间段,不一定要硬编码白天、黄昏等时长,可以在数据库中存时间段的配置,启动时加载。
  - 在游戏启动时,可以使用多线程或异步IO的方式,并行加载地图、精灵、物品数据,减少启动时间。
  - 使用中介者模式实现WebSocket的事件处理,避免服务类之间直接耦合。


## 架构设计

- Nginx做反向代理和负载均衡
- 多个Java服务器：一个Java服务器负责一个地图，不过rest请求还是可以用nginx做负载均衡
- Redis做缓存
- MySQL做持久化

## 部署

使用docker-compose吧

如何用nginx反向代理websocket？参见 https://blog.csdn.net/qq_25919479/article/details/126035517

更远的计划：spring cloud, k8s

## 缓存

- 使用redis作为缓存（直接用cachable的注解吧，比较方便）
- 对于每个地图独有的数据，例如物品的坐标，不需要redis，直接用java的并发容器放在Java内存里比较快，但需要定期写回MySQL

## 前端

### 素材

bing prompt: 

> cute cartoon dog, white background, Illustration, Graphic Design, Minimalism, simple, color, front view

### matter碰撞更加优雅

您可以尝试使用一个对象来存储不同类型物体之间的碰撞处理函数，这样可以避免在 `collisionstart` 事件处理器中使用大量的 `if` 语句。以下是一个示例：

1. 首先，定义一个对象来存储不同类型物体之间的碰撞处理函数：

```javascript
const collisionHandlers = {
  player_enemy: function(player, enemy) {
    // 玩家与敌人碰撞的逻辑
  },
  player_collectible: function(player, collectible) {
    // 玩家与可收集物体碰撞的逻辑
  },
  // 更多处理函数...
};
```

2. 然后，在 `collisionstart` 事件处理器中，根据碰撞物体的类别来调用相应的处理函数：

```javascript
this.matter.world.on('collisionstart', (event, bodyA, bodyB) => {
  const categories = [bodyA.collisionFilter.category, bodyB.collisionFilter.category].sort();
  const handlerKey = categories.join('_');

  if (collisionHandlers.hasOwnProperty(handlerKey)) {
    collisionHandlers[handlerKey](bodyA.gameObject, bodyB.gameObject);
  }
});
```

这样，您可以将碰撞处理逻辑与事件处理器分离，使代码更加清晰和易于维护。当然，这种方法仍然需要您为不同类型物体之间的碰撞定义处理函数，但它可以避免在 `collisionstart` 事件处理器中使用大量的 `if` 语句。

### 音频素材

jsfxr


## 角色模块

- 经验值每到100就导致等级升一级
- 饱腹值最高为100，高于80时会定期回复血量
- 角色的等级提升会提高各属性值，并解锁之前不能购买的商品或者是工厂里不能制作的东西
- 猫会不定期为你捕鱼，并且跑得很快，较难被攻击到
- 玩家养的牛可以宰杀，收获牛革和牛肉，牛革可以做皮质胸甲以及其他物品
- 牛会在草地附近移动，在草地附近才会繁殖，牛有寿命，牛也不能被怪物或其他玩家攻击
- 游戏中可以加入基于ChatGPT的AI虚拟人物，这些AI可以自由活动，也可以和玩家进行交互

## 账号模块

- 玩家第1次作弊（例如瞬移）会被警告，第2次封号7天，第3次封号30天，第4次永久封号

## 地图模块

- 玩家可以选择地图
- 使用柏林噪声生成不同的地形

## 时间模块

- 只有晚上会生成一些怪
- 黎明时怪开始迅速受伤死亡

## 建筑模块

- 建筑包含商店、农田、树、草地、池塘、工厂、铁矿、围墙等
- 玩家可以采集材料、建造建筑
- 建筑可以升级，提高产出和效率
- 动物园可以买动物
- 建筑和神奇物品由工厂制造
- 只有集市中，玩家可以以任意价格卖出商品，等待其他玩家购买
- 池塘可以捕鱼（需要手持鱼竿），需要花费一定时间，玩家创建的池塘，如果被别人捕鱼，自己也会获得部分收益（金钱和经验值）
- 铁矿可以挖铁（需要手持锄头），需要花费一定时间，玩家创建的铁矿，如果被别人挖铁，自己也会获得部分收益（金钱和经验值）
- 树可以用来砍（手持锯子时）或摘苹果（手不持锯子时），需要花费一定时间，玩家种植的树，如果被别人使用，自己也会获得部分收益（金钱和经验值）
- 工厂可以使用各种物品合成各种商店买不到的东西，例如各种建筑或珍贵物品，玩家自己创建的工厂，当发生交易时，自己会获得部分收益（金钱和经验值）
- 这些建筑里面可获得的东西，量都是有限的，当然也会定期（例如黎明的瞬间）自动补充
- 前端：首先怎么在客户端检测位置是否合法？弄一个polygon然后检测碰撞？注意不要与建筑之外的东西产生碰撞，也就是，还需要弄mask
- 希腊神庙，怪物无法靠近
- 将建筑的黑白图的白色变成透明，随后，建造建筑时就跟随光标显示这个图，为方便起见，只在服务器检测位置是否合法

## 聊天模块

- 玩家之间可以聊天
- 玩家也可以广播消息
- 聊天内容会被保留7天

## 战斗模块

- 玩家之间不能战斗
- 只有玩家与怪之间、怪与怪之间才会战斗
- 发射子弹，空气阻力很小，并且不透明度与速度正相关，通过服务器同步，但是服务器本身不需要保存子弹的状态，只用在客户端进行碰撞检测
- 怪物分为近身攻击和远程攻击两种，它们会寻找一定范围内的玩家，并进行攻击。近身攻击的怪是蜘蛛（蜘蛛在遭到碰撞时会旋转）
- 玩家能够进行两种攻击，右键对手时会朝对方发射子弹，子弹只能攻击敌人，而会穿过其他玩家
- 玩家右键点击自己可以进行范围攻击
- 玩家对怪造成伤害，会增加自己的经验值
- 玩家杀死怪时，会增加自己的经验值和金钱
- 竞技场：类似赛尔号

## 成就模块

增加成就模块，一些功能需要解锁特定成就才能进行

## 移动端适配

- 在PC端，点击左键显示一个东西的信息，点击右键攻击他，在地图上右键一个位置移动到那里
- 在移动端，点击一个东西攻击他，在地图上点击一个位置移动到那里，长按显示一个东西的信息

