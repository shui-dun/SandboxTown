# TODO

## feature

- java调试：如何调试springboot？如何调试docker中的springboot？

- 对于敌对生物，有一些共有的特征：（重点是如何抽象出公共的行为？）
  - 无法靠近希腊神庙。实现方法是：
    - 定义枚举类：`public enum MapBit {BLANK, BUILDING, WALL, SURROUNDING_GREEK_TEMPLE, SURROUNDING_TOMBSTONE}`
    
    - 修改地图点的含义：
      
      - buildingsHashCode: 当前建筑的hashcode，如果不是建筑物后32位为0
      - map
        - 第0位为1表示是空地（从低到高，这样传给前段时数据量小）
        - 第1位为1表示为建筑
        - 第2位为1表示为围墙
        - 第3位为1表示希腊神庙的周围
        - 第4位为1表示在墓碑的周围
      
    - 这样之后，我们就可以通过与 `(1 << MapBit.BUILDING.ordinal()) | (1 << MapBit.WALL.ordinal())` 进行与运算，通过结果是否为0来判断是不是障碍物，可以进一步封装出以下方法：
      ```
      private static int mapBitArrayToInt(MapBit... bits) {
          int result = 0;
          for (MapBit bit : bits) {
              result |= (1 << bit.ordinal());
          }
          return result;
      }
      ```
    
    - spriteAgent提供一个 `MapBitsPermissions mapBitsPermissions()` 方法，其中MapBitsPermissions包含3个int32：
    
      - `int obstacleBits`，例如如果obstacleBits在WALL这一位为1表示该精灵无法进入围墙，优先级最高。
    
      - `int permittedBits`，例如如果permittedBits包含SURROUNDING_TOMBSTONE表示该精灵只能在墓碑周围移动（地缚灵在血量低于30时可以自由移动，否则只能在墓碑周围）。优先级仅次于obstacleBits。
    
      - spriteAgent提供 `int forbiddenBits`，例如如果forbiddenBits在SURROUNDING_GREEK_TEMPLE这一位为1表示该精灵无法进入希腊神庙周围（蜘蛛和地缚灵在等于大于等于6时可以进入希腊神庙，否则不能进入）。优先级最低
    
  - 不会主动攻击装备隐身帽的生物
  
- 地缚灵可以穿墙以及穿过建筑物

- 添加聊天模块：
  - 私聊（目前这些功能的后端全部实现了，但尚未实现前端）：
    - 界面分为左右两栏，左栏是列表，右栏是聊天窗口
    - 左栏又分为上侧（按钮区）和下侧（列表），按钮区包含搜索（搜索玩家）、好友（好友列表）、黑名单（黑名单列表）
    - 左栏下侧的列表每一项包含从左到右3部分，左侧有一个圆形用于装饰，中部分为上下两部分（上侧是加粗放大的用户名，下侧是最后一条消息），右侧是未读消息数目（具有灰色的圆角矩形背景），左栏下侧的列表的顺序是按照最后一条消息的id进行排序。
    - 整个界面的右侧是聊天窗口，进入聊天界面，自动定位到最后一条已读消息
    - 聊天窗口也分为上中下3部分。
    - 聊天窗口的上部分是用户信息，包含用户名、拉黑用户（或者取消拉黑）按钮、文本框（用于填写搜索关键字）和搜索聊天内容按钮。点击搜索，将直接改变聊天窗口的中部的聊天气泡列表(每次加载20条的消息，往上滑就加载前20条消息)。
    - 聊天窗口的中部是聊天气泡，聊天从上到下按时间顺序排列，对方发的消息靠近左侧，而自己发的消息靠近右侧。气泡支持文本、图片、视频、文件四种形式。
    - 聊天窗口的下方分为从左到右3部分。
    - 聊天窗口的下方左侧是文本栏，可以输入文本
    - 聊天窗口的下方的中侧是附件按钮，点击出现下拉框，包含图片、视频、文件四个选项
    - 聊天窗口的下方右侧是发送按钮，当包含附件时，发送附件，不包含附件但包含文本时，发送文本并将文本栏置空，什么都不包含时，不做操作。按回车也有发送的效果。
    - 不在聊天界面时，得到新消息时会得到通知，在聊天界面时，将消息发起者放到界面左侧列表的顶部，如果正在和其聊天，则直接添加聊天气泡
    - 右键聊天气泡，包含编辑消息和删除消息的按钮。注意，对于图片、视频、文件，只包含删除消息的按钮。
    - 在聊天窗口中，每次加载20条的消息，往上滑就加载前20条消息，往下滑就加载后20条消息
    - 适配移动端，将好友列表和聊天窗口作为两个页面而不是左右排列，聊天窗口上回退将进入好友列表。
  - 消息加密
  - 玩家也可以建群。
    - 数据库设计：
      - group_admin表：groupId，userId（可以解散群，可以踢人、禁言）（groupId，userId作为主键）
      - group_user表：id, groupId，userId（id方便游标分页）
      - group_blacklist表：groupId，userId
      - group_mute表：groupId，userId，endTime
      - group_message表：id，groupId，userId，msgType，msgContent，time
    - 功能：
      - 创造群
      - 搜索群
      - 加入群
      - 踢人（也可以取消黑名单）
      - 禁言（也可以取消禁言和修改禁言时间）
      - 查看群成员列表、群管理员列表、禁言列表、黑名单

- 集群：
  - k8s进行容器编排，实现自动扩展
  - 要考虑如何减少内存占用，不然集群太占内存：
    - SpringBoot GraalVM Native Image Support
    - 很多服务应该不需要tomcat，尽量精简依赖
    - 使用k3s替代k8s
  - java微服务（也可以考虑不用微服务，单体也可以集群）
    - 服务切分：用户服务、游戏服务（包含从用户接收和发送websocket消息、维护地图缓存、精灵状态缓存、时间信息等）、聊天服务、成就模块、物品模块、精灵模块等
    - 每个微服务也可以有多个实例
      - 游戏服务是有状态的，每个游戏服务实例负责多个不同的地图而非仅仅一个地图
      - 成就模块什么的大多数模块是无状态的，这些无状态的模块可以直接负载均衡，数据库也可以按照服务来拆分
    - 通信方式：
      - 同步（RPC）：需要返回值的调用必要用rpc这种同步的方式实现（为简单起见，直接使用spring自带的RestTemplate）
        - 可以精灵交互时（首先尝试驯服，无效则尝试攻击），游戏服务首先调用精灵模块来获得驯养动物的返回值，以此判断是否需要进一步调用精灵模块的攻击方法
      - 异步（消息队列RabbitMQ）：
        - 例如获得物品后可能会解锁成就，但获得物品后其实可以马上返回，不需要同步地计算解锁成就的逻辑，因此引入消息队列，获得物品后发送获得物品的消息直接返回，成就服务收到消息后判断是否解锁某些成就。
        - 游戏服务之间基本上不会相互调用，因为一个地图不会跨越多个游戏服务，但是聊天服务之间可能会相互调用，因为两个正在聊天的用户可能与不同的聊天服务建立的websocket连接，因此这两个聊天服务之间会转发消息，可以将消息放在消息队列上
    - bean重复定义问题：
      - 创建一个共享的库（sandbox_town_common），包含所有公共的模型或DTO。它不应该是一个完整的Spring Boot应用，而只是包含共享的bean。然后在不同的服务中作为依赖项引入这个库。这样，每个服务都可以使用相同的数据结构。但是呢，docker是由构建上下文的，其他service无法访问sandbox_town_common，不知道怎么解决呢？
      - 重复定义：在每个服务中单独定义相同的模型或DTO。干脆写个脚本进行bean的复制，不仅复制到后端各服务，或者更进一步地，也复制到前端，使前端类型安全
    
  - 消息队列例如RabbitMQ：数据分片等技术（也可以直接用redis做消息队列）
  - redis
    - 读写分离
    - 数据分片

  - MySQL
    - 读写分离
    - 分库：可以按照微服务的划分把数据库也拆开
    - 分表，比如每一个群组是一个表，而不是一个大的群组表
    - 冷热分离：太久之前的聊天消息放入冷表

  - 如何进行压力测试？

- docker-compose指定启动顺序

- 生命药水：交互时给目标恢复血量

- 经验药水

- 宝箱可以开启任意物品（和商店一样，以稀有度作为概率）

- 使用 `jpa` 和 `query DSL` 代替 `mybatis`，可以不要完全替代mybatis，而是只在微服务的某些服务中这样做

- 玩家物品、商家物品分页：
  - 商品表、物品表设置递增的主键，这样方便游标分页
  - 每次后端给前端5页，前端只有在最后一页并尝试往后翻时向后端请求新数据

- java bean继承，例如使用 `new SpriteEffectChangeVo(spriteId)` 替代 `new WSResponseVo(WSResponseEnum.SPRITE_EFFECT_CHANGE, new SpriteEffectChangeVo(spriteId))`，其中 `SpriteEffectChangeVo` 继承自 `WSResponseVo`

- 完成虚无的效果

- 多地图（一个Java服务器负责一个地图） & rest请求用nginx做负载均衡

- 一个地图中有多个子地图，通过传送门切换

- 自动生成各种枚举类（可借助rest api）

- 优化自动生成各个说明文档（可借助rest api），这些生成脚本不应该删除已有的介绍内容，例如对狗狗行为规则的介绍，同时应该展示物品的详细信息（例如给精灵带来的效果）

- 使用spring cloud, k8s替代docker-compose

- 添加修炼场：一个修炼场所，精灵呆在里面一定时间可以获得特殊效果，例如“一定概率秒杀对方”或者“经验球”，或者直接获得经验值更方便

- 使用ai p图，生成各个精灵的各种动作的图片，例如行走（各个方向）、攻击、受伤、死亡等

- 设计以下武器（prompt：xxx, white background, Illustration, Minimalism, color, simple, Simplicity,Simplicity, Clear Lines and Shapes, front view, Iconic Representation, a little kawaii, Functional simplicity, Geometric simplicity）：
  - 埃阿斯之盾：体力上限+7，受到伤害时50%概率将伤害值+1后反弹给攻击者
  - 雷霆之杖（LightningBolts）：无视对方防具，并对对方造成30s烧伤效果
  - 青龙偃月刀：一定概率秒杀对方
  - 湖中剑：造成特定数值的固定伤害
  - 荷鲁斯之眼：生命和饱腹值恢复到满，并带有30s生命效果
  - 可以冰冻对方，对方不能move和interact

- 添加额外效果表(item_type_extra_effect)，例如对于埃阿斯之盾的“受到伤害时50%概率将伤害值+1后反弹给攻击者”的效果，后端计算时是直接if(装备名)来触发，而不是通过if(effect)来触发，前端效果列表中也不会显示，只是在前端的物品详细列表中会展示。

- 添加音频素材（jsfxr）

- 物品的生命值一直没有变化，应该随着使用而减少（例如攻击时手持武器生命值减少，被攻击时防具生命值减少）

- 物品的等级目前没有发挥作用

- 对于效果，设计一个value值和等级值，例如不同等级的“生命”效果回复速度不同

- 待定：简化设计，废弃整个物理引擎（因为bug太多了，不仅要解决自己代码的bug，还要解决物理引擎的上游bug），进而，可以简化前后端交互（废弃COORDINATE request，服务器不再需要通过前端获得位置信息）和后端设计（废弃SpriteCache，因为SpriteCache的主要目的就是缓存精灵位置，便于COORDINATE）

- 在游戏启动时,可以使用多线程或异步IO的方式,并行加载地图、精灵、物品数据,减少启动时间。

- 竞技场：类似赛尔号

- 使用柏林噪声生成不同的地形

- 需要邀请码才能注册，管理员可以查看、添加和删除邀请码

- 面板界面太长时可以滚动

- 增加成就模块，一些功能需要解锁特定成就才能进行

- 远程攻击：发射子弹，空气阻力很小，并且不透明度与速度正相关，通过服务器同步，但是服务器本身不需要保存子弹的状态，只用在客户端进行碰撞检测

- 实现范围攻击

- 角色的等级提升会解锁之前不能购买的商品或者是工厂里不能制作的东西

- 完成池塘 & 猫会不定期为你捕鱼，并且跑得很快，较难被攻击到

- 玩家养的牛可以宰杀，收获牛革和牛肉，牛革可以做皮质胸甲以及其他物品

- 牛会在草地附近移动，在草地附近才会繁殖，牛有寿命，牛也不能被怪物或其他玩家攻击

- 游戏中可以加入基于ChatGPT的AI虚拟人物，这些AI可以自由活动，也可以和玩家进行交互

- 玩家第1次作弊（例如瞬移）会被警告，第2次封号7天，第3次封号30天，第4次永久封号

- 击败不同等级的精灵获得的属性增益和物品数目不同

- 建筑模块
  - 建筑包含商店、农田、树、草地、池塘、工厂、铁矿、围墙等
  - 玩家可以采集材料、建造建筑
  - 建筑可以升级，提高产出和效率
  - 动物园可以买动物
  - 建筑和神奇物品由工厂制造
  - 只有集市中，玩家可以以任意价格卖出商品，等待其他玩家购买
  - 池塘可以捕鱼（需要手持鱼竿），需要花费一定时间，玩家创建的池塘，如果被别人捕鱼，自己也会获得部分收益（金钱和经验值）
  - 铁矿可以挖铁（需要手持锄头），需要花费一定时间，玩家创建的铁矿，如果被别人挖铁，自己也会获得部分收益（金钱和经验值）
  - 树可以用来砍（手持锯子时）或摘苹果（手不持锯子时），需要花费一定时间，玩家种植的树，如果被别人使用，自己也会获得部分收益（金钱和经验值）
  - 工厂可以使用各种物品合成各种商店买不到的东西，例如各种建筑或珍贵物品，玩家自己创建的工厂，当发生交易时，自己会获得部分收益（金钱和经验值）。
    - 工厂页面分成配方表和合成界面两个标签页。
    - 配方表中显示物品列表，灰色表示当前玩家不能合成，正常颜色表示当前玩家可以合成。点击去后是合成该物品的所有的方法。这些物品同样可以搜索或通过类型来筛选，也要进行分页。
    - 合成界面上方是已添加的物品列表，下方是背包内容，点击背包中物品，弹出选择数目界面，点确定添加到上方。
  - 这些建筑里面可获得的东西，量都是有限的，当然也会定期（例如黎明的瞬间）自动补充
  - 玩家建造建筑是，如何检测位置是否合法？
    - 法一：弄一个polygon然后检测碰撞？注意不要与建筑之外的东西产生碰撞，也就是，还需要弄mask
    - 法二（简单些）：将建筑的黑白图的白色变成透明，随后，建造建筑时就跟随光标显示这个图，为方便起见，只在服务器检测位置是否合法
  - 目前尚不支持除玩家以外的精灵到达建筑

- 可以选举主客户端，报告npc的消息，避免重复的消息

- 使用rabbitmq消息队列，客户端向服务端的消息发送消息，当然，服务端的任意模块也可以作为生产者向消息队列发送消息。服务端的各个模块作为消费者消费消息。这些模块高内聚低耦合，使得不需要加锁

- BO转化为VO给前端

- 使用Redis缓存更多需要的东西（简单的用cachable注解，复杂的写代码）

## bug

- 当我在 `swagger-ui` 中登录而不是通过前端登陆后，websocket将失效，即使重启浏览器也不行，必须要退出登录随后使用前端登录。
- 游戏处理流程应该完全地串行化（SpriteSchedule和用户请求不能同时进行），以避免 `GameCache.spriteCacheMap.get(xx).getXX()` 产生空指针异常
- 局域网多人游戏时，除服务器所在电脑以外的其他电脑上会有一些bug
  - 例如精灵移动时总是从同一位置出发
  - 字体过大，是电脑缩放比例的问题吗？
- 前端是否也应该加消息队列实现串行化？（避免一些空指针异常）
- 补间动画的精灵碰撞到带有速度的精灵，补间动画的精灵会再也无法正常运动，尝试在补间动画之前将速度设为0，这样的效果稍微好点，在碰到移动的物体后会像撞到一堵墙一样停止，但之后尝试运动还是可以正常运动，但目前能想到的最好的方法是在update中一直将补间动画的精灵的速度设为0
- 游戏进行中session正好到期，导致“无权限”的报错（解决方法是上线时自动续期？）
- 切换账号后，操纵的还是旧的玩家（旧的ws没有断开），需要刷新网页才能避免这个问题
- 服务器部署在海外时延迟高，精灵运动卡顿
- 移动端的问题（感觉难以解决，因此移动端可能只能聊天，不能进行游戏）：
  - 手机端的各个面板无法完整展示（太大）
  - 手机端的狗不会跟随主人移动，也不能与之进行交互，并且在其他用户的手机上这些狗也不可见
  - 手机端主页背景（小球运动）卡顿





