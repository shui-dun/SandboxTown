# 设计文档

## 技术选型

- 前端框架：Vue
- 游戏引擎：Phaser.js
- 通信协议：WebSocket & HTTP
- 后端框架：SpringBoot
- 数据库：Mysql
- 缓存：Redis
- 安全框架：Sa-Token

## 架构设计

- Nginx做反向代理和负载均衡
- 多个Java服务器：一个Java服务器负责一个地图，不过rest请求还是可以用nginx做负载均衡
- Redis做缓存
- MySQL做持久化

## 部署

使用docker-compose吧，暂时不上k8s

如何用nginx反向代理websocket？参见 https://blog.csdn.net/qq_25919479/article/details/126035517

## 通信格式

对于实时信息，使用websocket进行通信：

客户端发生事件（例如玩家被攻击）时，向服务器发送如下信息：

```json
{
    "type": "attack",
    "data": {
        "attacker": "attackerID",
        "victim": "victimID"
    }
}
```

同理，服务器向客户端返回的消息也同样是这种格式。

对于Rest API，通信格式如下：

```
{
	"code": 1,
	"msg": "用户不存在",
	"data": {}
}
```

## 缓存

- 使用redis作为缓存（直接用cachable的注解吧，比较方便）
- 对于每个地图独有的数据，例如物品的坐标，不需要redis，直接用java的并发容器放在Java内存里比较快，但需要定期写回MySQL

## 系统模块划分

## 账号模块

### 数据库设计

#### 用户表（user）

| 字段名       | 类型         | 描述             |
| ------------ | ------------ | ---------------- |
| username     | VARCHAR(255) | 用户名           |
| password     | VARCHAR(255) | 密码（加密存储） |
| salt         | VARCHAR(255) | 盐               |
| ban_end_date | DATETIME     | 封号结束时间     |
| cheat_count  | INT          | 作弊次数         |

#### 用户权限表（user_role）

| 字段名   | 类型         | 描述                      |
| -------- | ------------ | ------------------------- |
| username | VARCHAR(255) | 用户名                    |
| role     | VARCHAR(255) | 权限名（admin或者normal） |

### 接口设计

#### 注册接口

- URL: `/api/signup`
- Method: `POST`
- Request Body:
  - `username`: 用户名
  - `password`: 密码

#### 登录接口

- URL: `/user/login`
- Method: `POST`
- Request Body:
  - `username`: 用户名
  - `passwd`: 密码
  - `rememberMe`: 是否保持登录状态7天（可选，默认为false）

#### 查看是否登录

- URL: `/user/islogin`
- Method: `GET`

#### 退出登录

- URL: `/user/logout`
- Method: `POST`

#### 封号接口（仅管理员可用）

- URL: `/user/ban`
- Method: `POST`
- Request Body:
  - `username`: 用户名
  - `banEndDate`: 封号结束时间

#### 解封接口（仅管理员可用）

- URL: `/user/unban`
- Method: `POST`
- Request Body:
  - `username`: 用户名

## 游戏模块

### 算法

使用观察者模式：

观察者模式使用map实现，避免isinstanceof

```java
class ObserverNotifier {
    Map<EventEnum, List<Observer>> map;
    notifyAll(EventEnum);
}

class Observer {
    update();
}

class XXObserver {
    Map<EventEnum, Function> mp;
}
```

同时，还需要使用状态机维护观察者的状态

## 寻路模块

放到utils包里面吧

地图信息的导出，用Python通过physicsEditor的输出将建筑转化为bitmap

我们进行一次新寻路的条件判断, 主要抓住的是时间和位置. 如果时间间隔不够大(比如未到0.5sec), 就不寻路; 如果玩家没有移动, 那么怪物单位也没有必要再次进行寻路计算, 用之前的路线即可.


只取下面一部分的凹多面体（用于寻路算法，需要配合下面要将的算法）bitmap.json

> 引射线法是一种可行的方法来判断点是否在二维凹多边形内部。这种方法的基本思想是从目标点发出一条射线，然后统计射线与多边形边界的交点数目。如果交点数目是奇数，那么目标点在多边形内部；如果交点数目是偶数，那么目标点在多边形外部。

> 这种方法的正确性基于射线穿过多边形边界的次数。当射线穿过多边形边界时，它必然从多边形的内部穿到外部，或者从外部穿到内部。因此，如果交点数目是奇数，那么射线从多边形内部穿出了奇数次，说明目标点在多边形内部。相反，如果交点数目是偶数，那么射线从多边形内部穿出了偶数次，说明目标点在多边形外部。

> 下面是一个使用 Python 实现的示例：

```python
def is_point_inside_polygon(point, polygon):
    x, y = point
    n = len(polygon)
    inside = False

    p1x, p1y = polygon[0]
    for i in range(1, n + 1):
        p2x, p2y = polygon[i % n]
        if y > min(p1y, p2y):
            if y <= max(p1y, p2y):
                if x <= max(p1x, p2x):
                    if p1y != p2y:
                        x_intersection = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x
                    if p1x == p2x or x <= x_intersection:
                        inside = not inside
        p1x, p1y = p2x, p2y

    return inside

# 测试
point = (3, 4)
polygon = [(0, 0), (5, 0), (
```

## 前端

matter碰撞更加优雅：您可以尝试使用一个对象来存储不同类型物体之间的碰撞处理函数，这样可以避免在 `collisionstart` 事件处理器中使用大量的 `if` 语句。以下是一个示例：

1. 首先，定义一个对象来存储不同类型物体之间的碰撞处理函数：

```javascript
const collisionHandlers = {
  player_enemy: function(player, enemy) {
    // 玩家与敌人碰撞的逻辑
  },
  player_collectible: function(player, collectible) {
    // 玩家与可收集物体碰撞的逻辑
  },
  // 更多处理函数...
};
```

2. 然后，在 `collisionstart` 事件处理器中，根据碰撞物体的类别来调用相应的处理函数：

```javascript
this.matter.world.on('collisionstart', (event, bodyA, bodyB) => {
  const categories = [bodyA.collisionFilter.category, bodyB.collisionFilter.category].sort();
  const handlerKey = categories.join('_');

  if (collisionHandlers.hasOwnProperty(handlerKey)) {
    collisionHandlers[handlerKey](bodyA.gameObject, bodyB.gameObject);
  }
});
```

这样，您可以将碰撞处理逻辑与事件处理器分离，使代码更加清晰和易于维护。当然，这种方法仍然需要您为不同类型物体之间的碰撞定义处理函数，但它可以避免在 `collisionstart` 事件处理器中使用大量的 `if` 语句。

## 建筑模块

### 算法

前端：首先怎么在客户端检测位置是否合法？弄一个polygon然后检测碰撞？注意不要与建筑之外的东西产生碰撞，也就是，还需要弄mask

## 商店模块

模块设计要变一下，不能都作为建筑模块，建筑模块只管建造什么的，每个建筑都要有自己的模块

# GPT4之前写的

## 账号模块

用户模块负责处理用户的注册、登录、权限管理等功能。与其他模块的交互主要包括：

- 向地图模块提供用户权限信息，以判断用户是否可以创建新地图
- 向经济模块提供用户信息，以便记录用户的金钱和经验值
- 向任务模块提供用户信息，以便记录用户的任务进度
- 向多人游戏模块提供用户信息，以便实现玩家间的互动

### 数据结构

- User类：包含用户的基本信息，如用户名、密码、邮箱等。
- UserRole枚举：定义用户角色，如普通用户、管理员等。
- IUserService：定义用户服务接口，包括注册、登录、获取用户信息、更新用户信息等方法。
- UserService：实现IUserService接口。

### 算法

- 使用JWT进行用户认证：生成和验证JWT令牌。
- 密码加密：使用bcrypt进行密码加密和验证。

### 数据库设计

| 字段名     | 类型         | 描述             |
| ---------- | ------------ | ---------------- |
| id         | INT          | 用户ID（主键）   |
| username   | VARCHAR(255) | 用户名           |
| password   | VARCHAR(255) | 密码（加密存储） |
| email      | VARCHAR(255) | 邮箱地址         |
| role       | VARCHAR(255) | 用户角色         |
| experience | INT          | 经验值           |
| money      | DECIMAL      | 金钱             |
| created_at | TIMESTAMP    | 创建时间         |
| updated_at | TIMESTAMP    | 更新时间         |

### API设计

- 注册：`POST /api/users/register`
- 登录：`POST /api/users/login`
- 获取用户信息：`GET /api/users/{id}`
- 更新用户信息：`PUT /api/users/{id}`

## 地图模块

地图模块负责地图的生成、存储和加载。与其他模块的交互主要包括：

- 接收用户模块提供的用户权限信息，判断用户是否可以创建新地图
- 向建筑模块提供地图信息，以便在地图上放置建筑物
- 向任务模块提供地图信息，以便生成任务相关的地点和事件

### 数据结构

- Map类：包含地图的基本信息，如名称、创建者ID、地图数据等。
- Tile枚举：定义地图上的不同类型的瓦片，如草地、沙地、水域等。
- IMapService：定义地图服务接口，包括获取地图列表、创建地图、获取地图详情、更新地图、删除地图等方法。
- MapService：实现IMapService接口。

### 算法

- 使用Perlin噪声算法生成随机地图
- 地图数据以JSON格式存储

### 数据库设计

| 字段名     | 类型         | 描述             |
| ---------- | ------------ | ---------------- |
| id         | INT          | 地图ID（主键）   |
| name       | VARCHAR(255) | 地图名称         |
| user_id    | INT          | 创建者ID（外键） |
| data       | JSON         | 地图数据         |
| created_at | TIMESTAMP    | 创建时间         |
| updated_at | TIMESTAMP    | 更新时间         |

### API设计

- 获取地图列表：`GET /api/maps`
- 创建地图：`POST /api/maps`
- 获取地图详情：`GET /api/maps/{id}`
- 更新地图：`PUT /api/maps/{id}`
- 删除地图：`DELETE /api/maps/{id}`

## 建筑模块

建筑模块负责建筑物的创建、修改和删除。与其他模块的交互主要包括：

- 接收地图模块提供的地图信息，以便在地图上放置建筑物
- 向经济模块提供建筑物信息，以便计算收益和支出
- 向任务模块提供建筑物信息，以便生成与建筑物相关的任务

### 数据结构

- Building类：包含建筑的基本信息，如名称、类型、所属用户ID、所在地图ID、建筑位置、建筑数据等。
- BuildingType枚举：定义不同类型的建筑，如房屋、商店、工厂等。
- IBuildingService：定义建筑服务接口，包括获取建筑列表、创建建筑、获取建筑详情、更新建筑、删除建筑等方法。
- BuildingService：实现IBuildingService接口。

### 算法

- 建筑物的创建、修改和删除操作需要验证用户权限
- 建筑物数据以JSON格式存储

### 数据库设计

| 字段名     | 类型         | 描述               |
| ---------- | ------------ | ------------------ |
| id         | INT          | 建筑ID（主键）     |
| name       | VARCHAR(255) | 建筑名称           |
| type       | VARCHAR(255) | 建筑类型           |
| user_id    | INT          | 所属用户ID（外键） |
| map_id     | INT          | 所在地图ID（外键） |
| position   | JSON         | 建筑位置           |
| data       | JSON         | 建筑数据           |
| created_at | TIMESTAMP    | 创建时间           |
| updated_at | TIMESTAMP    | 更新时间           |

### API设计

- 获取建筑列表：`GET /api/buildings`
- 创建建筑：`POST /api/buildings`
- 获取建筑详情：`GET /api/buildings/{id}`
- 更新建筑：`PUT /api/buildings/{id}`
- 删除建筑：`DELETE /api/buildings/{id}`

## 经济模块

经济模块负责处理游戏内的金钱和经验值。与其他模块的交互主要包括：

- 接收用户模块提供的用户信息，以便记录用户的金钱和经验值
- 接收建筑模块提供的建筑物信息，以便计算收益和支出
- 向任务模块提供金钱和经验值信息，以便作为任务奖励

### 数据结构

- Economy类：包含用户的经济信息，如金钱、经验值等。
- IEconomyService：定义经济服务接口，包括获取用户经济信息、更新用户经济信息等方法。
- EconomyService：实现IEconomyService接口。

### 算法

- 使用观察者模式监听建筑、任务等模块的变化，实时更新用户的金钱和经验值

### API设计

- 获取用户经济信息：`GET /api/economy/{user_id}`
- 更新用户经济信息：`PUT /api/economy/{user_id}`

## 任务模块

任务模块负责生成和管理游戏任务。与其他模块的交互主要包括：

- 接收用户模块提供的用户信息，以便记录用户的任务进度
- 接收地图模块提供的地图信息，以便生成任务相关的地点和事件
- 接收建筑模块提供的建筑物信息，以便生成与建筑物相关的任务
- 向经济模块请求金钱和经验值信息，以便作为任务奖励

### 数据结构

- Task类：包含任务的基本信息，如名称、描述、类型、状态、执行者ID、任务奖励等。
- TaskType枚举：定义不同类型的任务，如建筑任务、收集任务、探险任务等。
- TaskStatus枚举：定义任务的不同状态，如未开始、进行中、已完成、已领取奖励等。
- ITaskService：定义任务服务接口，包括获取任务列表、创建任务、获取任务详情、更新任务、删除任务等方法。
- TaskService：实现ITaskService接口。

### 算法

- 任务生成算法根据用户等级、地图信息和建筑信息生成任务
- 任务状态包括：未开始、进行中、已完成、已领取奖励

### 数据库设计

| 字段名      | 类型         | 描述             |
| ----------- | ------------ | ---------------- |
| id          | INT          | 任务ID（主键）   |
| name        | VARCHAR(255) | 任务名称         |
| description | TEXT         | 任务描述         |
| type        | VARCHAR(255) | 任务类型         |
| status      | VARCHAR(255) | 任务状态         |
| user_id     | INT          | 执行者ID（外键） |
| reward      | JSON         | 任务奖励         |
| created_at  | TIMESTAMP    | 创建时间         |
| updated_at  | TIMESTAMP    | 更新时间         |

### API设计

- 获取任务列表：`GET /api/tasks`
- 创建任务：`POST /api/tasks`
- 获取任务详情：`GET /api/tasks/{id}`
- 更新任务：`PUT /api/tasks/{id}`
- 删除任务：`DELETE /api/tasks/{id}`

## 多人游戏模块

多人游戏模块负责实现玩家间的互动。与其他模块的交互主要包括：

- 接收用户模块提供的用户信息，以便实现玩家间的互动
- 向地图模块请求地图信息，以便在多人游戏中共享地图
- 向建筑模块请求建筑物信息，以便在多人游戏中共享建筑物

### 数据结构

- Player类：包含在线玩家的基本信息，如用户名、所在地图ID等。
- Message类：包含聊天消息的基本信息，如发送者、接收者、内容等。
- IMultiplayerService：定义多人游戏服务接口，包括获取在线玩家列表、加入游戏、离开游戏、发送消息等方法。
- MultiplayerService：实现IMultiplayerService接口。

### 算法

- 使用WebSocket实现实时通信
- 使用Redis存储在线玩家信息

### API设计

- 获取在线玩家列表：`GET /api/multiplayer/players`
- 加入游戏：`POST /api/multiplayer/join`
- 离开游戏：`POST /api/multiplayer/leave`
- 发送消息：`POST /api/multiplayer/message`

## AI虚拟人物模块

AI虚拟人物模块负责生成和管理基于ChatGPT的AI虚拟人物。与其他模块的交互主要包括：

- 向任务模块提供AI虚拟人物信息，以便生成与AI虚拟人物相关的任务
- 向多人游戏模块提供AI虚拟人物信息，以便在多人游戏中实现与AI虚拟人物的互动

### 数据结构

- AICharacter类：包含虚拟人物的基本信息，如名称、类型、对话数据等。
- AICharacterType枚举：定义不同类型的虚拟人物，如商人、导师、村民等。
- IAICharacterService：定义AI虚拟人物服务接口，包括获取虚拟人物列表、创建虚拟人物、获取虚拟人物详情、更新虚拟人物、删除虚拟人物等方法。
- AICharacterService：实现IAICharacterService接口。

### 算法

- 使用OpenAI的ChatGPT作为AI虚拟人物的对话引擎
- 虚拟人物数据以JSON格式存储

### API设计

- 获取虚拟人物列表：`GET /api/ai-characters`
- 创建虚拟人物：`POST /api/ai-characters`
- 获取虚拟人物详情：`GET /api/ai-characters/{id}`
- 更新虚拟人物：`PUT /api/ai-characters/{id}`
- 删除虚拟人物：`DELETE /api/ai-characters/{id}`

