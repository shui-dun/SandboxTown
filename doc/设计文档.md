# 设计文档

## 技术选型

- 前端框架：Vue
- 游戏引擎：Phaser.js
- 通信协议：WebSocket & HTTP
- 后端框架：SpringBoot
- 数据库：Mysql
- 缓存：Redis
- 安全框架：Sa-Token

## 架构设计

- Nginx做反向代理和负载均衡（如何用nginx反向代理websocket？参见 https://blog.csdn.net/qq_25919479/article/details/126035517）
- 多个Java服务器：一个Java服务器负责一个地图，不过rest请求还是可以用nginx做负载均衡
- Redis做缓存
- MySQL做持久化

## 通信格式

对于实时信息，使用websocket进行通信：

客户端发生事件（例如玩家被攻击）时，向服务器发送如下信息：

```json
{
    "type": "attack",
    "data": {
        "attacker": "attackerID",
        "victim": "victimID"
    }
}
```

同理，服务器向客户端返回的消息也同样是这种格式。

对于Rest API，通信格式如下：

```
{
	"code": 1,
	"msg": "用户不存在",
	"data": {}
}
```

## 系统模块划分

## 游戏模块

使用观察者模式：

- 在前端，你可以使用Phaser.js的事件系统来监听游戏中的事件，例如敌人攻击玩家。当检测到碰撞时，向后端发送消息
- 在后端，你可以使用观察者模式来处理事件。首先，创建一个事件接口和一个观察者接口
- 接下来，创建一个具体的事件类，例如`EnemyAttackEvent`，实现`Event`接口。
- 然后，创建具体的观察者类，例如`PlayerObserver`和`DogObserver`，实现`Observer`接口。

同时，还需要使用状态机维护观察者的状态



根据需求，我们可以将系统划分为以下模块：

1. 账号模块
1. 地图模块
1. 时间模块
1. 建筑模块
1. 聊天模块
1. 战斗模块
1. NPC模块
1. 属性模块











## 用户模块

用户模块负责处理用户的注册、登录、权限管理等功能。与其他模块的交互主要包括：

- 向地图模块提供用户权限信息，以判断用户是否可以创建新地图
- 向经济模块提供用户信息，以便记录用户的金钱和经验值
- 向任务模块提供用户信息，以便记录用户的任务进度
- 向多人游戏模块提供用户信息，以便实现玩家间的互动

### 数据结构

- User类：包含用户的基本信息，如用户名、密码、邮箱等。
- UserRole枚举：定义用户角色，如普通用户、管理员等。
- IUserService：定义用户服务接口，包括注册、登录、获取用户信息、更新用户信息等方法。
- UserService：实现IUserService接口。

### 算法

- 使用JWT进行用户认证：生成和验证JWT令牌。
- 密码加密：使用bcrypt进行密码加密和验证。

### 数据库设计

| 字段名     | 类型         | 描述             |
| ---------- | ------------ | ---------------- |
| id         | INT          | 用户ID（主键）   |
| username   | VARCHAR(255) | 用户名           |
| password   | VARCHAR(255) | 密码（加密存储） |
| email      | VARCHAR(255) | 邮箱地址         |
| role       | VARCHAR(255) | 用户角色         |
| experience | INT          | 经验值           |
| money      | DECIMAL      | 金钱             |
| created_at | TIMESTAMP    | 创建时间         |
| updated_at | TIMESTAMP    | 更新时间         |

### API设计

- 注册：`POST /api/users/register`
- 登录：`POST /api/users/login`
- 获取用户信息：`GET /api/users/{id}`
- 更新用户信息：`PUT /api/users/{id}`

## 地图模块

地图模块负责地图的生成、存储和加载。与其他模块的交互主要包括：

- 接收用户模块提供的用户权限信息，判断用户是否可以创建新地图
- 向建筑模块提供地图信息，以便在地图上放置建筑物
- 向任务模块提供地图信息，以便生成任务相关的地点和事件

### 数据结构

- Map类：包含地图的基本信息，如名称、创建者ID、地图数据等。
- Tile枚举：定义地图上的不同类型的瓦片，如草地、沙地、水域等。
- IMapService：定义地图服务接口，包括获取地图列表、创建地图、获取地图详情、更新地图、删除地图等方法。
- MapService：实现IMapService接口。

### 算法

- 使用Perlin噪声算法生成随机地图
- 地图数据以JSON格式存储

### 数据库设计

| 字段名     | 类型         | 描述             |
| ---------- | ------------ | ---------------- |
| id         | INT          | 地图ID（主键）   |
| name       | VARCHAR(255) | 地图名称         |
| user_id    | INT          | 创建者ID（外键） |
| data       | JSON         | 地图数据         |
| created_at | TIMESTAMP    | 创建时间         |
| updated_at | TIMESTAMP    | 更新时间         |

### API设计

- 获取地图列表：`GET /api/maps`
- 创建地图：`POST /api/maps`
- 获取地图详情：`GET /api/maps/{id}`
- 更新地图：`PUT /api/maps/{id}`
- 删除地图：`DELETE /api/maps/{id}`

## 建筑模块

建筑模块负责建筑物的创建、修改和删除。与其他模块的交互主要包括：

- 接收地图模块提供的地图信息，以便在地图上放置建筑物
- 向经济模块提供建筑物信息，以便计算收益和支出
- 向任务模块提供建筑物信息，以便生成与建筑物相关的任务

### 数据结构

- Building类：包含建筑的基本信息，如名称、类型、所属用户ID、所在地图ID、建筑位置、建筑数据等。
- BuildingType枚举：定义不同类型的建筑，如房屋、商店、工厂等。
- IBuildingService：定义建筑服务接口，包括获取建筑列表、创建建筑、获取建筑详情、更新建筑、删除建筑等方法。
- BuildingService：实现IBuildingService接口。

### 算法

- 建筑物的创建、修改和删除操作需要验证用户权限
- 建筑物数据以JSON格式存储

### 数据库设计

| 字段名     | 类型         | 描述               |
| ---------- | ------------ | ------------------ |
| id         | INT          | 建筑ID（主键）     |
| name       | VARCHAR(255) | 建筑名称           |
| type       | VARCHAR(255) | 建筑类型           |
| user_id    | INT          | 所属用户ID（外键） |
| map_id     | INT          | 所在地图ID（外键） |
| position   | JSON         | 建筑位置           |
| data       | JSON         | 建筑数据           |
| created_at | TIMESTAMP    | 创建时间           |
| updated_at | TIMESTAMP    | 更新时间           |

### API设计

- 获取建筑列表：`GET /api/buildings`
- 创建建筑：`POST /api/buildings`
- 获取建筑详情：`GET /api/buildings/{id}`
- 更新建筑：`PUT /api/buildings/{id}`
- 删除建筑：`DELETE /api/buildings/{id}`

## 经济模块

经济模块负责处理游戏内的金钱和经验值。与其他模块的交互主要包括：

- 接收用户模块提供的用户信息，以便记录用户的金钱和经验值
- 接收建筑模块提供的建筑物信息，以便计算收益和支出
- 向任务模块提供金钱和经验值信息，以便作为任务奖励

### 数据结构

- Economy类：包含用户的经济信息，如金钱、经验值等。
- IEconomyService：定义经济服务接口，包括获取用户经济信息、更新用户经济信息等方法。
- EconomyService：实现IEconomyService接口。

### 算法

- 使用观察者模式监听建筑、任务等模块的变化，实时更新用户的金钱和经验值

### API设计

- 获取用户经济信息：`GET /api/economy/{user_id}`
- 更新用户经济信息：`PUT /api/economy/{user_id}`

## 任务模块

任务模块负责生成和管理游戏任务。与其他模块的交互主要包括：

- 接收用户模块提供的用户信息，以便记录用户的任务进度
- 接收地图模块提供的地图信息，以便生成任务相关的地点和事件
- 接收建筑模块提供的建筑物信息，以便生成与建筑物相关的任务
- 向经济模块请求金钱和经验值信息，以便作为任务奖励

### 数据结构

- Task类：包含任务的基本信息，如名称、描述、类型、状态、执行者ID、任务奖励等。
- TaskType枚举：定义不同类型的任务，如建筑任务、收集任务、探险任务等。
- TaskStatus枚举：定义任务的不同状态，如未开始、进行中、已完成、已领取奖励等。
- ITaskService：定义任务服务接口，包括获取任务列表、创建任务、获取任务详情、更新任务、删除任务等方法。
- TaskService：实现ITaskService接口。

### 算法

- 任务生成算法根据用户等级、地图信息和建筑信息生成任务
- 任务状态包括：未开始、进行中、已完成、已领取奖励

### 数据库设计

| 字段名      | 类型         | 描述             |
| ----------- | ------------ | ---------------- |
| id          | INT          | 任务ID（主键）   |
| name        | VARCHAR(255) | 任务名称         |
| description | TEXT         | 任务描述         |
| type        | VARCHAR(255) | 任务类型         |
| status      | VARCHAR(255) | 任务状态         |
| user_id     | INT          | 执行者ID（外键） |
| reward      | JSON         | 任务奖励         |
| created_at  | TIMESTAMP    | 创建时间         |
| updated_at  | TIMESTAMP    | 更新时间         |

### API设计

- 获取任务列表：`GET /api/tasks`
- 创建任务：`POST /api/tasks`
- 获取任务详情：`GET /api/tasks/{id}`
- 更新任务：`PUT /api/tasks/{id}`
- 删除任务：`DELETE /api/tasks/{id}`

## 多人游戏模块

多人游戏模块负责实现玩家间的互动。与其他模块的交互主要包括：

- 接收用户模块提供的用户信息，以便实现玩家间的互动
- 向地图模块请求地图信息，以便在多人游戏中共享地图
- 向建筑模块请求建筑物信息，以便在多人游戏中共享建筑物

### 数据结构

- Player类：包含在线玩家的基本信息，如用户名、所在地图ID等。
- Message类：包含聊天消息的基本信息，如发送者、接收者、内容等。
- IMultiplayerService：定义多人游戏服务接口，包括获取在线玩家列表、加入游戏、离开游戏、发送消息等方法。
- MultiplayerService：实现IMultiplayerService接口。

### 算法

- 使用WebSocket实现实时通信
- 使用Redis存储在线玩家信息

### API设计

- 获取在线玩家列表：`GET /api/multiplayer/players`
- 加入游戏：`POST /api/multiplayer/join`
- 离开游戏：`POST /api/multiplayer/leave`
- 发送消息：`POST /api/multiplayer/message`

## AI虚拟人物模块

AI虚拟人物模块负责生成和管理基于ChatGPT的AI虚拟人物。与其他模块的交互主要包括：

- 向任务模块提供AI虚拟人物信息，以便生成与AI虚拟人物相关的任务
- 向多人游戏模块提供AI虚拟人物信息，以便在多人游戏中实现与AI虚拟人物的互动

### 数据结构

- AICharacter类：包含虚拟人物的基本信息，如名称、类型、对话数据等。
- AICharacterType枚举：定义不同类型的虚拟人物，如商人、导师、村民等。
- IAICharacterService：定义AI虚拟人物服务接口，包括获取虚拟人物列表、创建虚拟人物、获取虚拟人物详情、更新虚拟人物、删除虚拟人物等方法。
- AICharacterService：实现IAICharacterService接口。

### 算法

- 使用OpenAI的ChatGPT作为AI虚拟人物的对话引擎
- 虚拟人物数据以JSON格式存储

### API设计

- 获取虚拟人物列表：`GET /api/ai-characters`
- 创建虚拟人物：`POST /api/ai-characters`
- 获取虚拟人物详情：`GET /api/ai-characters/{id}`
- 更新虚拟人物：`PUT /api/ai-characters/{id}`
- 删除虚拟人物：`DELETE /api/ai-characters/{id}`
